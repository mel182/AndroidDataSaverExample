package com.example.datasaverexampleapp.video_audio.audio_playback_focus

import android.annotation.SuppressLint
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.media.AudioAttributes
import android.media.AudioFocusRequest
import android.media.AudioManager
import android.os.Build
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import android.os.Handler
import android.util.Log
import com.example.datasaverexampleapp.R
import kotlinx.android.synthetic.main.activity_audio_playback_example.*

class AudioPlaybackFocusExampleActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_audio_playback_example)
        title = "Audio playback example"
        requestAudioFocus()
        registerAudioBecomingNoisyReceiver()
    }

    //region Request audio focus
    private fun requestAudioFocus()
    {
        // To request audio focus before beginning playback, use the Audio Manager's requestAudioFocus method.
        // When requesting the audio focus, you can specify which stream you require (typically STREAM_MUSIC)
        //, and for how long you expect to require focus-either ongoing (such as when playing music)
        // or transiently (such as when providing navigation instructions). In the latter case you can also
        // specify if your transiently interruption can be handled by the currently focused application
        // "ducking" (lowering its volume) until your interruption is complete.
        //
        // There are cases - such as when the user is in a phone call - when a request for audio focus will fail.
        // As a result, you should be careful to only start playback if you receive AUDIOFOCUS_REQUEST_GRANTED
        // after making the request.
        //
        // Note: The sounds generated by Notifications are a special case. Android will automatically request temporary
        //       audio focus doe Notification sounds added via setSound, or by using the DEFAULT_SOUND or DEFAULT_ALL flag
        //       for setDefaults. It's important to utilize these methods for associating audio with your
        //       Notification to ensure that you honor the user's Do Not Disturb settings.
        val audioManager = getSystemService(Context.AUDIO_SERVICE) as AudioManager

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O)
        {
            val handler = Handler()
            val focusRequest = AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN).run {
                setAudioAttributes(AudioAttributes.Builder().run {
                    setUsage(AudioAttributes.USAGE_MEDIA)
                    setContentType(AudioAttributes.CONTENT_TYPE_MUSIC)
                    build()
                })
                setAcceptsDelayedFocusGain(true)
                setOnAudioFocusChangeListener({ focusChange ->

                    // Audio focus is assigned to each application that request it.
                    // That means that if another application request audio focus,
                    // your application will lose it.
                    //
                    // The 'focusChange' parameter indicates the nature of the focus loss - either transient or ongoing
                    // - and whether ducking is permitted.
                    //
                    // BEST PRACTICE: It's best practice to pause your media playback whenever you lose audio focus, or,
                    //                in the case of a transient loss that supports ducking, to lower the volume of your
                    //                audio output.

                    when(focusChange)
                    {
                        AudioManager.AUDIOFOCUS_LOSS -> {
                            // Permanent loss of audio
                            // Pause playback immediately
                        }

                        AudioManager.AUDIOFOCUS_LOSS_TRANSIENT -> {
                            // Pause playback
                            // You will be notified when you have regained focus by
                            // AUDIOFOCUS_GAIN.
                        }

                        AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK -> {
                            // Lower the volume (while ducking) and keep playing
                        }

                        AudioManager.AUDIOFOCUS_GAIN -> {
                            // Your app has been granted audio focus gain
                            // Raise volume to normal, restart playback if necessary
                        }
                    }

                }, handler)
                build()
            }

            val focusLock = Any()
            var playbackDelayed = false
            var playbackNowAuthorized = false

            // requesting audio focus and processing the response
            val res = audioManager.requestAudioFocus(focusRequest)
            synchronized(focusLock) {
                playbackNowAuthorized = when (res) {
                    AudioManager.AUDIOFOCUS_REQUEST_FAILED -> {
                        Log.i("TAG23","Audio focus request failed")
                        // Request failed cannot play or stream media
                        false
                    }
                    AudioManager.AUDIOFOCUS_REQUEST_GRANTED -> {
                        Log.i("TAG23","Audio focus request granted 2")
                        // Can play or stream media
                        true
                    }
                    AudioManager.AUDIOFOCUS_REQUEST_DELAYED -> {
                        Log.i("TAG23","Audio focus request delayed")
                        // Playback delayed
                        false
                    }
                    else -> false
                }
            }

        } else {

            val result = audioManager.requestAudioFocus({ focusChange ->
                Log.i("TAG23","Audio focus change: $focusChange")
            }, AudioManager.STREAM_MUSIC, AudioManager.AUDIOFOCUS_GAIN)

            if (result == AudioManager.AUDIOFOCUS_REQUEST_GRANTED)
            {
                // Request granted, so you can start playing or streaming media
                Log.i("TAG23","Audio focus request granted")
            } else {
                // Request failed so unable to play or stream media
                Log.i("TAG23","Audio focus request failed")
            }
        }
    }
    //endregion

    //region Pausing playback When the Output Changes
    // If the current output stream is a headset, disconnecting it will result in the system automatically
    // switching output to the device's speakers. It's considered a good practice to pause (or reduce the volume)
    // of your audio output in these circumstances.
    // To do so, create a Broadcast Receiver that listens for the AudioManager.ACTION_AUDIO_BECOMING_NOISY broadcast
    // and pause your playback.
    //
    // IMPORTANT: Because this broadcast is only needed when your app is actively playing audio/video, it is not appropriate
    //            to register this receiver in your manifest. Instead, you should create an instance of your 'BroadcastReceiver'
    //            and register it programmatically when you start playback (after receiving audio focus) and unregister it when you
    //            pause playback.
    private val audioBecomeNoisyReceiver = object : BroadcastReceiver() {
        @SuppressLint("SetTextI18n")
        override fun onReceive(context: Context?, intent: Intent?) {
            intent?.let {  intentReceived ->
                if (intentReceived.action == AudioManager.ACTION_AUDIO_BECOMING_NOISY)
                {
                    audio_noisy_textView?.text = "Audio becomes noisy!"
                }
            }
        }
    }

    private fun registerAudioBecomingNoisyReceiver()
    {
        registerReceiver(audioBecomeNoisyReceiver, IntentFilter(AudioManager.ACTION_AUDIO_BECOMING_NOISY))
    }
    //endregion



    override fun onDestroy() {
        super.onDestroy()
        unregisterReceiver(audioBecomeNoisyReceiver)
    }


}